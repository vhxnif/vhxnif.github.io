<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Where子句 :: vhxnif site</title>
    <meta name="generator" content="Antora 3.1.9">
    <script>
!function (theme, navWidth) {
  if (theme === 'dark') document.documentElement.classList.add('dark-theme')
  if (navWidth) document.documentElement.style.setProperty('--nav-width', `${navWidth}px`)
}(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'),
  localStorage && localStorage.getItem('nav-width'))
    </script>
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/search.css">
    <link rel="stylesheet" href="../../_/css/vendor/page-search.css">
    <link rel="stylesheet" href="../../_/css/vendor/spring-tabs.css">

    <meta name="antora-ui-version" content="984f7191b09b6903979cea4d001155aadc3cfc00"> 
    <meta name="version" content="">
    <meta name="component" content="site">
    <meta name="latest-version" content="false">
    <link rel="icon" href="../../_/img/favicon.ico" type="image/vnd.microsoft.icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item">
        <img
          id="springlogo"
          class="block"
          src="../../_/img/note-logo.svg"
          alt="Spring"
        />
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <label class="theme-toggler">
      <input
        type="checkbox"
        type="checkbox"
        id="switch-theme-checkbox"
        name="switch-theme-checkbox"
      />
      <span class="icon"><svg
          aria-hidden="true"
          focusable="false"
          data-prefix="fas"
          data-icon="moon"
          class="svg-inline--fa fa-moon moon"
          role="img"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 384 512"
        ><path
            fill="currentColor"
            d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"
          ></path>
        </svg>
        <svg
          aria-hidden="true"
          focusable="false"
          data-prefix="fas"
          data-icon="sun"
          class="svg-inline--fa fa-sun sun"
          role="img"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 512 512"
        ><path
            fill="currentColor"
            d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"
          ></path>
        </svg></span>
      <span class="text">light</span>
    </label>
  </nav>
</header>
<script>
!function (theme) {
  if (theme === 'dark') {
    document.getElementById('switch-theme-checkbox').parentElement.classList.add('active')
  }
}(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'))
</script>
<div class="body">
<div class="nav-container"  data-component="site"
  data-version="" >
  <aside class="nav">
    <div class="panels">
      <div class="nav-panel-menu is-active" data-panel="menu">
        <nav class="nav-menu">
          <div class="context">
  <span class="title">vhxnif site</span>
  <span class="version">default</span>
  <button class="browse-version" id="browse-version">
    <svg
      height="24px"
      id="Layer_1"
      style="enable-background:new 0 0 512 512;"
      version="1.1"
      viewBox="0 0 512 512"
      width="24px"
      xml:space="preserve"
    ><g><path
          d="M256,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S273.7,224,256,224L256,224z"
        ></path><path
          d="M128.4,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S146,224,128.4,224L128.4,224z"
        ></path><path
          d="M384,224c-17.7,0-32,14.3-32,32s14.3,32,32,32s32-14.3,32-32S401.7,224,384,224L384,224z"
        ></path></g></svg>
  </button>
  </div>          <ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Log</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link"  href="../log/MDC-util.html">MDC</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Maven</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link"  href="../maven/maven.html">Maven</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">MyBatis-Plus</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link"  href="../mybatis-plus/GlobalTypeHandler.html">GlobalTypeHandler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link"  href="../mybatis-plus/TypeHandler.html">TypeHandler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Spring</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link"  href="../spring/Interception.html">Interception</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Test</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link"  href="../test/k6.html">Grafana k6</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Sql</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Use the Index Note</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link"  href="index-anatomy.html">Anatomy of an Index</a>
  </li>
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link"  href="index-where-clause.html">The Where Clause</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
          <div class="toggle-sm">
            <button id="nav-toggle-2" class="nav-toggle"></button>
          </div>
        </nav>
      </div>
      <div class="nav-collapse">
        <button id="nav-collapse-toggle"><span></span></button>
      </div>
    </div>
    <div class="nav-resize"></div>
  </aside>
</div>
<script>
  !function (sidebar) {
    if (sidebar) {
      document.body.classList.add('nav-sm')
    }
  }(localStorage && localStorage.getItem('sidebar') === 'close')
</script><main class="article">
<div class="toolbar" role="navigation">
  <button id="nav-toggle-1" class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="sidebar">
  <div class="content">
    <div
      class="toc"
      data-title="Where子句"
      data-levels="2"
    >
      <div class="toc-menu"></div>
    </div>
  </div>
</aside>
<article class="doc">
<div class="breadcrumbs-container">
  <nav class="breadcrumbs" aria-label="breadcrumbs">
    <ul>
      <li><a href="../index.html">vhxnif site</a></li>
      <li>Sql</li>
      <li>Use the Index Note</li>
      <li><a href="index-where-clause.html">The Where Clause</a></li>
    </ul>
  </nav>
</div><h1 id="page-title" class="page">Where子句</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><code>where</code> 子句定义了SQL语句的搜索条件，因此它属于索引的核心功能领域：快速查找数据。尽管 <code>where</code> 字句对性能有巨大的影响，但它往往被草率的表述，导致数据库不得不扫描索引的大部分内容。一个编写不佳的 <code>where</code> 子句是导致慢查询的首要原因。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_相等运算符"><a class="anchor" href="#_相等运算符"></a>相等运算符</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_主键"><a class="anchor" href="#_主键"></a>主键</h3>
<div id="example_table_employees" class="listingblock">
<div class="title">示例使用的EMPLOYEES表</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE employees (
   employee_id   NUMBER         NOT NULL,
   first_name    VARCHAR2(1000) NOT NULL,
   last_name     VARCHAR2(1000) NOT NULL,
   date_of_birth DATE           NOT NULL,
   phone_number  VARCHAR2(1000) NOT NULL,
   CONSTRAINT employees_pk PRIMARY KEY (employee_id)
)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">使用下面的语句查询员工姓名</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name
  FROM employees
 WHERE employee_id = 123</code></pre>
</div>
</div>
<div class="paragraph">
<p>主键约束确保了 <code>employee_id</code> 的唯一性，数据库无需遍历索引节点&#8212;&#8203;只需要遍历索引树即可。可以通过执行计划来验证。</p>
</div>
<div class="listingblock">
<div class="title">MySQL</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">+----+-----------+-------+---------+---------+------+-------+
| id | table     | type  | key     | key_len | rows | Extra |
+----+-----------+-------+---------+---------+------+-------+
|  1 | employees | const | PRIMARY | 5       |    1 |       |
+----+-----------+-------+---------+---------+------+-------+

const 类型在MySQL中相当于Oracle中的INDEX UNIQUE SCAN。</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Oracle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">---------------------------------------------------------------
|Id |Operation                   | Name         | Rows | Cost |
---------------------------------------------------------------
| 0 |SELECT STATEMENT            |              |    1 |    2 |
| 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES    |    1 |    2 |
|*2 |  INDEX UNIQUE SCAN         | EMPLOYEES_PK |    1 |    1 |
---------------------------------------------------------------</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PostgreSQL</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">                QUERY PLAN
-------------------------------------------
 Index Scan using employees_pk on employees
   (cost=0.00..8.27 rows=1 width=14)
   Index Cond: (employee_id = 123::numeric)

PostgreSQL的Index Scan结合了Oracle数据库中的Index [UNIQUE/RANGE] SCAN和TABLE ACCESS BY INDEX ROWID访问表的操作，无法看出是否可能返回多行。</code></pre>
</div>
</div>
<div class="paragraph">
<p>访问索引后，数据库还需要执行一个步骤从表存储中获取查询的数据(first_name、last_name)，即执行 <strong>TABLE ACCESS BY INDEX ROWID</strong> 。此操作可能会成为性能瓶颈，但是在 <strong>INDEX UNIQUE  SCAN</strong>操作中不存在此类风险，该操仅返回一条记录，不会触发多次表访问，不会导致查询缓慢。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Primary Keys without Unique Index</div>
<div class="paragraph">
<p>主键并不一定需要唯一索引——同样可以使用非唯一索引。在这种情况下，Oracle 数据库不会使用<strong> INDEX UNIQUE SCAN</strong>操作，而是采用<strong>INDEX RANGE SCAN</strong>操作。尽管如此，约束依然保持键的唯一性，使得索引查询最多返回一个条目。</p>
</div>
<div class="paragraph">
<p>使用非唯一索引作为主键的原因之一是可延迟约束。与在语句执行期间进行验证的常规约束相反，数据库会将可延迟约束的验证推迟到事务提交时进行。对于插入具有循环依赖关系的表中的数据，需要延迟约束。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_联合索引"><a class="anchor" href="#_联合索引"></a>联合索引</h3>
<div class="paragraph">
<p>尽管数据库会自动为主键创建索引，但是如果主键由多个键组合而成，仍有机会进行手动优化。
在这种情况下，数据库会在所有主键列上创建索引--<code>联合索引</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
联合索引的列顺序对其可用性的影响比较大，必须谨慎选择。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>继续使用<a href="#example_table_employees">EMPLOYEES</a>表，假设有一家公司合并，另一家公司的员工被添加到EMPLOYEES表中，<code>EMPLOYEE_ID</code>在两家公司之间并不唯一 。
我们需要通过一个额外的标识来扩展主键，例如，一个子公司ID 。
因此，新的主键包含两个列：<code>EMPLOYEE_ID</code>和<code>SUBSIDIARY_ID</code>。</p>
</div>
<div class="paragraph">
<p>新主键的定义如下：<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE UNIQUE INDEX employees_pk
    ON employees (employee_id, subsidiary_id)</code></pre>
</div>
</div>
<div class="paragraph">
<p>查询特定员工的时候，需要考虑完整的主键：<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name
FROM employees
WHERE employee_id = 123
AND subsidiary_id = 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用了完整的唯一主键时，数据库可以采用唯一索引扫描&#8212;&#8203;无论该索引包含多少个列。
如果只使用主键列之一，例如，搜索某个子公司的所有员工，会如何执行扫描呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name
FROM employees
WHERE subsidiary_id = 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行计划显示，数据库未使用索引，而是执行了<code>全表扫描</code>。
因此，数据库读取整个表并对每一行根据where子句进行评估。
执行时间随表大小增长而增加，如果表大小增长十倍，全表扫描所需要的时间也将增加十倍。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">全表扫描</div>
<div class="paragraph">
<p>操作<code>TABLE ACCESS FULL</code>，在某些场景下，尤其是检索表的大部分数据，可能是最有效的操作。</p>
</div>
<div class="paragraph">
<p>原因在于索引查找本身的开销，索引的查找是逐块读取的，数据库在处理完当前块之前并不知道接下来需要读取哪个块。
<code>FULL TABLE SCAN</code>无论如何都必须读取整个表，因此数据库可以一次性读取更大的数据块（多块读取）。
尽管数据库读取的数据量更多，但是可能需要执行的读取操作次数更少。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>数据库不使用该索引是因为它无法随意的组合索引中的单个列。
联合索引和其他B- Tree索引一样，将索引数据保存在一个有序列表中。
数据库根据索引定义中的外置来考虑每一列，以对索引条目进行排序。
第一列是主要的排序标准，第二列仅在两个条目的第一列具有相同值时决定顺序，以此类推。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">联合索引</div>
<div class="imageblock">
<div class="content">
<img src="../_images/idx_concatenated.png" alt="idx concatenated">
</div>
</div>
<div class="paragraph">
<p>图中的索引摘录显示，<code>subsidiary_id=20</code>的条目并没有彼此相邻存储。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>我们可以通过为subsidiary_id单独建一个索引来提高查询速度<a id="two-index"></a>。
如果employee_id对于搜索没有意义，可以通过反转索引列的顺序来更好的实现。<a id="single-index"></a></p>
</div>
<div id="example-pk" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE UNIQUE INDEX EMPLOYEES_PK ON EMPLOYEES (SUBSIDIARY_ID, EMPLOYEE_ID)</code></pre>
</div>
</div>
<div class="paragraph">
<p>两列合并后仍然唯一。
因此使用完整的主键索引的查询仍然可以使用唯一索引进行扫描，但是索引条目的顺序已经完全不同，subsidiary_id已经成为主要的排序标准。
可以通过执行计划验证，查询已经可以使用索引。
subsidiary_id已经不再唯一，因此数据库必须遍历所有的叶节点以找到所有匹配的条目。</p>
</div>
<div class="listingblock">
<div class="title">MySQL</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">+----+-----------+------+---------+---------+------+-------+
| id | table     | type | key     | key_len | rows | Extra |
+----+-----------+------+---------+---------+------+-------+
|  1 | employees | ref  | PRIMARY | 5       |  123 |       |
+----+-----------+------+---------+---------+------+-------+
MySQL访问类型ref相当于Oracle数据库的INDEX RNAGE SCAN</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Oracle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">---------------------------------------------------------------
|Id |Operation                   | Name         | Rows | Cost |
---------------------------------------------------------------
| 0 |SELECT STATEMENT            |              |  106 |   75 |
| 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES    |  106 |   75 |
|*2 |  INDEX RANGE SCAN          | EMPLOYEES_PK |  106 |    2 |
---------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("SUBSIDIARY_ID"=20)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PostgreSQL</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">                 QUERY PLAN
----------------------------------------------
 Bitmap Heap Scan on employees
 (cost=24.63..1529.17 rows=1080 width=13)
   Recheck Cond: (subsidiary_id = 2::numeric)
   -&gt; Bitmap Index Scan on employees_pk
      (cost=0.00..24.36 rows=1080 width=0)
      Index Cond: (subsidiary_id = 2::numeric)

在这种情况下，PostgreSQL数据库使用两种操作：首先是Bitmap Index Scan， 然后是Bitmap Head Scan。大致对应Oracle的 INDEX RANGE SCAN 和 TABLE ACCESS BY INDEX ROWID。又一个重要的区别在于首先从索引中获取所有的结果（Bitmap Index Scan），然后根据堆表中行的物理存储位置，对行进行排序，接着从表中获取所有行（Bitmap Heap Scan）。这种方法减少了表上的随机访问IO次数。</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
联合索引最关键的因素是如何选择列的顺序，以便可能频繁的使用索引。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通常情况下，数据库在以最左列进行搜索时，可以使用组合索引。一个包含三列的索引（A，B，C），在搜索第一列时（A），同时搜索前两列（A，B），以及使用所有列搜索时， 都可以被利用。</p>
</div>
<div class="paragraph">
<p>尽管<a href="#two-index">两个索引</a>解决方案在查询性能方面表现非常出色。
但<a href="#single-index">单索引</a>的解决方案更加可取，它不仅节省了存储空间，还减少了维护第二个索引的开销。
表中的索引越少，插入、删除、更新的性能就越好。</p>
</div>
<div class="paragraph">
<p>要定义一个最佳的索引，不仅需要了解索引的工作原理，还必须知道应用程序如何查询数据。开发者需要考虑数据的访问路径，建立恰当的索引，从而以最小的努力为整个应用带来最大的收益。</p>
</div>
</div>
<div class="sect2">
<h3 id="_慢索引_p2"><a class="anchor" href="#_慢索引_p2"></a>慢索引 P2</h3>
<div class="paragraph">
<p>下面说明数据库选择索引的方式，以及更改现有索引可能潜在的副作用。</p>
</div>
<div class="paragraph">
<p>采用<a href="#example-pk">EMPLOYEES_PK</a>索引提升了所有仅按照subsidiary_id查询的性能。
同样也适用于所有按照subsidiary_id的查询，无论是否存在其他搜索条件。如果where子句中的其他条件可以使用其他索引，这种情况会存在多个可用的访问路径，选择最优的路径需要<code>优化器</code>来处理。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">查询优化器</div>
<div class="paragraph">
<p>查询优化器时数据库中将SQL语句转化为执行计划的核心组件。这个过程也被称为<code>编译</code>或<code>解析</code>。
存在两种不同的优化器类型:</p>
</div>
<div class="paragraph">
<p>基于成本的优化器（CBO）生成多种执行计划变体，并为每一个计划计算一个成本值。
成本的计算给予所使用的操作和估计的行数。
成本值将作为选择“最佳”执行计划的基准。</p>
</div>
<div class="paragraph">
<p>基于规则的优化器（RBO）使用硬编码的规则集生成执行计划。
基于规则的优化器灵活性较低，如今已经很少使用。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>更改索引可能会带来不愉快的副作用。在我们修改了<a href="#example-pk">索引</a>以后，导致了下面查询变慢。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name, subsidiary_id, phone_number
  FROM employees
 WHERE last_name  = 'WINAND'
   AND subsidiary_id = 30</code></pre>
</div>
</div>
<div id="pk-explain" class="listingblock">
<div class="title">explain 1</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">---------------------------------------------------------------
|Id |Operation                   | Name         | Rows | Cost |
---------------------------------------------------------------
| 0 |SELECT STATEMENT            |              |    1 |   30 |
|*1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES    |    1 |   30 |
|*2 |  INDEX RANGE SCAN          | EMPLOYEES_PK |   40 |    2 |
---------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
  1 - filter("LAST_NAME"='WINAND')
  2 - access("SUBSIDIARY_ID"=30)</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行计划使用了我们修改的索引，整体成本为30。考虑到<a href="#example_table_employees">旧的索引</a>只有EMPLOYEE_ID这一列，不在我们的where查询条件中，所以之前的查询是没有使用索引的。</p>
</div>
<div class="paragraph">
<p>禁用索引，并查询执行计划：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT /*+ NO_INDEX(EMPLOYEES EMPLOYEES_PK) */
       first_name, last_name, subsidiary_id, phone_number
  FROM employees
 WHERE last_name  = 'WINAND'
   AND subsidiary_id = 30</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">----------------------------------------------------
| Id | Operation         | Name      | Rows | Cost |
----------------------------------------------------
|  0 | SELECT STATEMENT  |           |    1 |  477 |
|* 1 |  TABLE ACCESS FULL| EMPLOYEES |    1 |  477 |
----------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("LAST_NAME"='WINAND' AND "SUBSIDIARY_ID"=30)</code></pre>
</div>
</div>
<div class="paragraph">
<p>查询仅匹配了1行数据，理论上使用索引应该比<code>TABLE ACCESS FULL</code>更快，但是实际情况却相反。
我们来仔细分析一下使用主键索引的<a href="#pk-explain">执行计划</a>。</p>
</div>
<div class="paragraph">
<p>索引范围扫描操作ID，仅使用<code>subsidiary_id=30</code>过滤器。
也就是说索引扫描操作会遍历索引树找到<code>subsidiary_id=30</code>的条目，然后沿着叶节点链查找该子公司的所有其他条目，索引范围扫描的结果随子公司员工的数量增大而增大。</p>
</div>
<div class="paragraph">
<p>下一步是根据索引ROWID访问表操作，获取到所有的员工数据行，再根据last_name过滤符合搜索条件的数据。</p>
</div>
<div class="paragraph">
<p>查询响应时间并不取决于结果集的大小，而是取决于特定子公司的员工数量。
如果子公司只有少量的员工，索引范围扫描会提供更好的性能，但是对于一个庞大的子公司，全表扫描可能会更快，因为它可以一次性从表中读取大量的数据。</p>
</div>
<div class="paragraph">
<p>选择最佳的执行计划不仅取决于表的数据分布，优化器还会利用数据库内容的统计信息。
在我们的示例中，使用了包含员工在子公司间分布情况的直方图。
这使得优化器能够估计从索引查找返回的行数，从而计算成本。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
基于成本的优化器使用关于表、列、和索引的统计信息。<br>
大多数统计信息是在列级别收集的：<br>
不同值的数量、最小和最大值（数据范围）、NULL出现的次数以及列直方图（数据分布）。<br>
表最重要的统计值是其大小（以行和块为单位）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果没有可用的统计信息（例如因为他们被删除了），优化器会使用默认值。
Oracle数据库的默认统计信息表明这是一个具有中等选择性的小型索引。
他们导致估计索引范围扫描将返回40行。
<a href="#pk-explain">执行计划</a>在Rows列中显示了这一估计。
显然这是一个严重的低估，实际上这家子公司有1000名员工。</p>
</div>
<div class="paragraph">
<p>如果我们提供准确的统计数据，优化器的工作效果会更好。
下面的执行计划展示了新的评估：索引范围扫描结果有1000行，后序的表访问需要更高的成本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">---------------------------------------------------------------
|Id |Operation                   | Name         | Rows | Cost |
---------------------------------------------------------------
| 0 |SELECT STATEMENT            |              |    1 |  680 |
|*1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES    |    1 |  680 |
|*2 |  INDEX RANGE SCAN          | EMPLOYEES_PK | 1000 |    4 |
---------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
  1 - filter("LAST_NAME"='WINAND')
  2 - access("SUBSIDIARY_ID"=30)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>680</code>的成本值高于全表扫描的成本值<code>477</code>，优化器会自动倾向于选择全表扫描。</p>
</div>
<div class="paragraph">
<p>上面的慢索引例子不应掩盖一个事实，即正确的索引是最佳的解决方案。
我们来给last_name添加索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE INDEX emp_name ON employees (last_name)</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用新的索引，执行计划如下，优化器计算出来一个新的成本值<code>3</code>。</p>
</div>
<div id="opt-idx-explain" class="listingblock">
<div class="title">explain 2</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">--------------------------------------------------------------
| Id | Operation                   | Name      | Rows | Cost |
--------------------------------------------------------------
|  0 | SELECT STATEMENT            |           |    1 |    3 |
|* 1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEES |    1 |    3 |
|* 2 |   INDEX RANGE SCAN          | EMP_NAME  |    1 |    1 |
--------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("SUBSIDIARY_ID"=30)
   2 - access("LAST_NAME"='WINAND')</code></pre>
</div>
</div>
<div class="paragraph">
<p>索引访问根据优化器的估计仅返回一行，因此，数据库只需从表中获取该行，比全表扫描更快。
<code>一个定义良好的索引仍然优于原始的却表扫描。</code></p>
</div>
<div class="paragraph">
<p><a href="#pk-explain">explain 1</a>和<a href="#opt-idx-explain">explain 2</a>两个执行计划几乎完全相同。
数据库执行相同的操作，优化器计算出的成本值也相似，然而第二个计划执行效果却好的多。
索引值范围扫描的效率可能在很大范围内变化&#8212;&#8203;尤其是在其后跟随表访问时。
使用索引并不意味着语句会以最佳的方式执行。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_function"><a class="anchor" href="#_function"></a>Function</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
MySQL默认不区分大小写，但是可以在列级别进行控制。
从<code>5.7</code>版本开始可以在 <a href="https://dev.mysql.com/doc/refman/8.0/en/generated-column-index-optimizations.html">生成列</a>上创建索引。<br>
Oracle 数据库<code>8i</code>版本其支持基于函数的索引。
虚拟列则是在<code>11g</code>版本中额外添加的。<br>
PostgraSQL自7.4版本其完全支持 <a href="https://www.postgresql.org/docs/current/indexes-expressional.html">表达式上的索引</a>。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_不区分大小写的搜索upper和lower"><a class="anchor" href="#_不区分大小写的搜索upper和lower"></a>不区分大小写的搜索<strong>UPPER</strong>和<strong>LOWER</strong></h3>
<div class="paragraph">
<p>在<code>where</code>子句中忽略大小写可以通过<strong>UPPER</strong>或者<strong>LOWER</strong>函数将<code>=</code>两边都转换为相同的的形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name, phone_number
FROM employees
WHERE UPPER(last_name) = UPPER('winand')</code></pre>
</div>
</div>
<div class="paragraph">
<p>无论搜索词或者<code>last_name</code>使用何种的大小写，<strong>UPPER</strong>函数都可以使其按照预期进行匹配。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
另一种实现不区分大小写匹配的方法是使用不同的“排序规则”。SQLServer和MySQL默认使用的排序规则是不区分大小写的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上面的查询逻辑虽然符合逻辑，但是执行计划却不尽人意。</p>
</div>
<div class="listingblock">
<div class="title">Oracle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">----------------------------------------------------
| Id | Operation         | Name      | Rows | Cost |
----------------------------------------------------
|  0 | SELECT STATEMENT  |           |   10 |  477 |
|* 1 |  TABLE ACCESS FULL| EMPLOYEES |   10 |  477 |
----------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter(UPPER("LAST_NAME")='WINAND')</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PostgraSQL</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">                     QUERY PLAN
------------------------------------------------------
 Seq Scan on employees
   (cost=0.00..1722.00 rows=50 width=17)
   Filter: (upper((last_name)::text) = 'WINAND'::text)</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的执行计划显示数据库使用了全表扫描。
尽管<code>last_name</code>列上有索引但是无法使用，因为搜索的不是<code>last_name</code>而是<code>UPPER(last_name)</code>对于数据库而言，二者是完全不同的东西。</p>
</div>
<div class="paragraph">
<p>对于我们人类而言可以立刻识别出<code>last_name</code>和<code>UPPER(last_name)</code>之间的区别，但是对于数据库优化器而言，其视角更像是下面的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name, phone_number
FROM employees
WHERE BLACKBOX(.... = UPPER('winand')</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>UPPER</strong>函数是一个黑盒。该函数的参数无关紧要，因为没有普遍的存在于函数参数与结果之间的关系。</p>
</div>
<div class="paragraph">
<p>为了支持上面的搜索，我们需要创建一个支持实际搜索词(<strong>UPPER(last_name)</strong>)的索引。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE INDEX emp_up_name On employees (UPPER(last_name))</code></pre>
</div>
</div>
<div class="paragraph">
<p>定义中包含函数或者表达式的索引被称为<strong>基于函数的索引（FBI）</strong>。
基于函数的索引不是直接将列数据复制到索引中，而是先执行函数，然后将函数的结果放入索引。
因此，索引存储的名称均为全大写的形式。</p>
</div>
<div class="paragraph">
<p>数据库可以使用基于函数的索引，前提是索引定义的精确表达式出现在SQL语句中。执行计划如下：<br></p>
</div>
<div id="fun-idx-explain" class="listingblock">
<div class="title">Oracle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">--------------------------------------------------------------
|Id |Operation                   | Name        | Rows | Cost |
--------------------------------------------------------------
| 0 |SELECT STATEMENT            |             |  100 |   41 |
| 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES   |  100 |   41 |
|*2 |  INDEX RANGE SCAN          | EMP_UP_NAME |   40 |    1 |
--------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
  2 - access(UPPER("LAST_NAME")='WINAND')</code></pre>
</div>
</div>
<div id="fun-idx-explain-pg" class="listingblock">
<div class="title">PostgraSQL</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">                       QUERY PLAN
------------------------------------------------------------
Bitmap Heap Scan on employees
  (cost=4.65..178.65 rows=50 width=17)
  Recheck Cond: (upper((last_name)::text) = 'WINAND'::text)
  -&gt; Bitmap Index Scan on emp_up_name
     (cost=0.00..4.64 rows=50 width=0)
     Index Cond: (upper((last_name)::text) = 'WINAND'::text)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上面的执行计划所示，优化器使用了<strong>INDEX RANGE SCAN</strong>扫描，数据库遍历B树然后遍历叶节点链。
函数型索引没有专用的运算或关键字。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
有时候ORM框架会隐式的使用<strong>UPPER</strong>和<strong>LOWER</strong>函数。例如，Hibernate会在进行不区分大小写搜索的时候隐式插入一个<strong>LOWER</strong>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#fun-idx-explain">执行计划</a>与之前<a href="#opt-idx-explain">不含<strong>UPPER</strong>的情况</a>不同：行数估计过高。
优化器预期从表中获取的行数（100），多于<strong>INDEX RANGE SCAN</strong>扫描所返回的行数（40）。
这种情况显然是矛盾的，说明表统计数据存在问题。
在本示例中，是由于Oracle数据库在创建新的索引的时候不会更新表的统计信息。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">基于函数的索引的Oracle统计信息</div>
<div class="paragraph">
<p>Oracle数据库将不同列值的数量作为表统计信息的一部分进行维护。
如果某列是多个索引的一部分，这些数据会重复利用。</p>
</div>
<div class="paragraph">
<p>基于函数的索引（FBI）的统计信息也会在表级别上作为虚拟列进行维护。
尽管Oracle数据库会自动收集新索引的索引统计信息（ <a href="https://docs.oracle.com/cd/B14117_01/server.101/b10763/compat.htm#sthref320">自10g版本起</a>），但是它不会更新表的统计信息。
因此Oracle文档建议在创建基于函数的索引后更新表统计信息。</p>
</div>
<div class="quoteblock">
<blockquote>
在创建居于函数的索引后，使用<strong>DBMS_ATATS</strong>包对索引及其基表收集统计信息。这些统计信息将使Oracle数据库能够正确决定何时使用该索引。
</blockquote>
<div class="attribution">
&#8212; <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/CREATE-INDEX.html#GUID-1F89BBC0-825F-4215-AF71-7588E31D8BFE__I2100962">Oracle 数据库SQL语言参考</a>
</div>
</div>
<div class="paragraph">
<p>个人建议，每次索引变更后，更新基表及其所有索引的统计信息。
可能会有副作用，请和DBA协调这个操作，并备份原始的统计信息。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>更新统计信息后 ，优化器可以更准确的估计值：+</p>
</div>
<div class="listingblock">
<div class="title">Oracle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">--------------------------------------------------------------
|Id |Operation                   | Name        | Rows | Cost |
--------------------------------------------------------------
| 0 |SELECT STATEMENT            |             |    1 |    3 |
| 1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES   |    1 |    3 |
|*2 |  INDEX RANGE SCAN          | EMP_UP_NAME |    1 |    1 |
--------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
  2 - access(UPPER("LAST_NAME")='WINAND')</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PostgraSQL</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">                      QUERY PLAN
----------------------------------------------------------
 Index Scan using emp_up_name on employees
   (cost=0.00..8.28 rows=1 width=17)
   Index Cond: (upper((last_name)::text) = 'WINAND'::text)</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着行数估计的减少&#8212;&#8203;从<a href="#fun-idx-explain-pg">之前</a>的50降至当前的1行&#8212;&#8203;查询计划器更倾向于使用更简单的索引扫描操作。</p>
</div>
<div class="paragraph">
<p>MySQL不支持上面的基于函数的索引，但是通过计算列或生成列提供了变通的方法。
要利用这一点，需要先向表中添加一个可随后进行索引的生成列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">ALTER TABLE employees
  ADD COLUMN last_name_up VARCHAR(255) AS (UPPER(last_name));

CREATE INDEX emp_up_name ON employees (last_name_up);</code></pre>
</div>
</div>
<div class="paragraph">
<p>MySQL在语句中出现索引表达式时能够使用此索引。</p>
</div>
</div>
<div class="sect2">
<h3 id="_用户自定义函数"><a class="anchor" href="#_用户自定义函数"></a>用户自定义函数</h3>
<div class="paragraph">
<p>基于函数的索引是一种非常通用的方法。
除了<strong>UPPER</strong>这样的函数外，还可以索引<code>A + B</code>这样的表达式，甚至可以在索引定义中使用自定义函数。</p>
</div>
<div class="paragraph">
<p>存在一个重要的例外情况，例如，无法在索引定义中直接或简介引用当前时间，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE FUNCTION get_age(date_of_birth DATE)
RETURN NUMBER
AS
BEGIN
  RETURN
    TRUNC(MONTHS_BETWEEN(SYSDATE, date_of_birth)/12);
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数<strong>GET_AGE</strong>利用当前日期（SYSDATE）根据提供的出生日期计算年龄。
我们可以在SQL语句中使用这个函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name, get_age(date_of_birth)
  FROM employees
 WHERE get_age(date_of_birth) = 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>看到上面的查询语句我们的第一印象是使用函数式索引来优化查询。
但是事实上我们不能在索引定义中使用<strong>GET_AGE</strong>函数，因为它是不确定的。
<strong>GET_AGE</strong>函数的调用结果并非完全由其参数决定。
只有对于相同的参数始终返回相同的结果的函数&#8212;&#8203;即确定性函数（函数式编程中的纯函数？）才可以被索引。</p>
</div>
<div class="paragraph">
<p>这个限制的原因很简单。
在插入新行时候，数据库会调用函数并将结果存储在索引中，此后该结果保持不变。
不存在定期更新索引的过程。
数据库仅在通过更新语句更改出生日期时才会更新索引中的年龄。
在下一次生日后，索引中存储的年龄将不在准确。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
尽管可以使用<strong>DETERMINISTIC</strong>将<strong>GET_AGE</strong>函数声为确定性函数。但是实际使用中，不会按照预期工作，因为索引中的员工年龄不会变。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>无法索引的其他函数还包括随机数生成器和依赖环境变量的函数等。</p>
</div>
</div>
<div class="sect2">
<h3 id="_过度索引"><a class="anchor" href="#_过度索引"></a>过度索引</h3>
<div class="paragraph">
<p>虽然函数式索引可以优化一些额外的逻辑查询，但是不要去索引所有的内容。
每个索引都会带来持续的维护工作。
基于函数式的索引特别容易产生冗余的索引。</p>
</div>
<div class="paragraph">
<p>上述的不区分大小写的搜索也可以通过<strong>LOWER</strong>函数来实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name, phone_number
  FROM employees
 WHERE LOWER(last_name) = LOWER('winand')</code></pre>
</div>
</div>
<div class="paragraph">
<p>单一的索引无法同时支持这两种忽略大小写的写法，如果要支持<strong>LOWER</strong>这种写法需要在<strong>LOWER(last_name)</strong>上创建另一个索引。
这样我们在每条数据插入、更新、删除的时候都需要维护两个索引。
我们应该避免这种情况，而是在应用程序中使用一致的忽略大小写查询的写法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
统一的访问路径，以便多个查询可以使用一个索引。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
始终致力于索引原始数据，因为这通常是你能放入索引中最有价值的信息。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参数化查询"><a class="anchor" href="#_参数化查询"></a>参数化查询</h2>
<div class="sectionbody">
<div class="paragraph">
<p>绑定参数&#8212;&#8203;也称为动态参数或绑定变量。
不是直接将之放入SQL中，而是使用一个占位符，例如<code>?</code>、<code>:name</code>或<code>@name</code>，并通过单独的API调用提供实际值。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">在临时语句中直接使用值并无不妥，然而在程序中使用绑定参数有两个充分的理由：</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">安全 </dt>
<dd>
<p>绑定变量是防止 <a href="https://en.wikipedia.org/wiki/SQL_injection">SQL注入</a>的最佳方法。</p>
</dd>
<dt class="hdlist1">性能 </dt>
<dd>
<p>具有执行计划缓存的 SQL Server 和 Oracle等数据库，在多次执行同一语句时，可以重用执行计划。
这节省了重建执行计划的工作量，但前提是SQL语句必须完全相同。
如果SQL语句中输入不同的值，数据库会将其视为不同的语句并重新构建新的执行计划。</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果受影响的数据量取决于实际值，那么优化器还是会创建新的执行计划：</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name
  FROM employees
 WHERE subsidiary_id = 20</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">----------------------------------------------------------------
|Id | Operation                   | Name         | Rows | Cost |
----------------------------------------------------------------
| 0 | SELECT STATEMENT            |              |   99 |   70 |
| 1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEES    |   99 |   70 |
|*2 |   INDEX RANGE SCAN          | EMPLOYEES_PK |   99 |    2 |
----------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("SUBSIDIARY_ID"=20)</code></pre>
</div>
</div>
<div class="paragraph">
<p>索引查找为小公司提供了最佳性能。但是对于大型子公司，全表扫描可能优于索引查找：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT first_name, last_name
  FROM employees
 WHERE subsidiary_id = 30</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">----------------------------------------------------
| Id | Operation         | Name      | Rows | Cost |
----------------------------------------------------
|  0 | SELECT STATEMENT  |           | 1000 |  478 |
|* 1 |  TABLE ACCESS FULL| EMPLOYEES | 1000 |  478 |
----------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("SUBSIDIARY_ID"=30)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种情况下，<code>subsidiary_id</code>上的直方图发挥了其作用。
优化器使用它来确定SQL查询中提到的子公司ID的频率。
因此，它为两个查询分别估算了不同的行数统计。
后序的成本计算将产生两个不同的成本值。
当优化器最终选择执行计划时，他会采用成本值最低的计划。</p>
</div>
<div class="paragraph">
<p>对于较小的子公司，使用索引扫描的执行计划成本最低。</p>
</div>
<div class="paragraph">
<p>通过ROWID访问表操作的成本对行数估计极为敏感。
选择十倍数量的行将使成本值按此倍数增加。
因此，使用索引扫描的总成本甚至高于全表扫描。
优化器据此选择全表扫描来处理更大员工的子公司查询。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>在使用参数绑定的时候，优化器无法活的具体值来确定器频率。
因此，它假设了一个均匀分布，并始终得到相同的行数估计和成本值。
最终，他总是会选择相同的执行计划。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
列直方图在数值分布不均匀时最为有用。<br>
对于具有均匀分布的列，通常只需要将不同值的数量除以表中行数即可。<br>
在使用绑定参数时，此方法同样适用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果我们将优化器比作是编译器，绑定变量及如同程序变量，但如果直接将其写入语句中，则更像是常量。
数据库在优化过程中可以利用SQL语句中的值，正如编译器在编译期间能够计算常量表达式一样。
<code>绑定参数对于优化器而言是不可见的，正如变量的运行时值对于编译器是未知的一样。</code></p>
</div>
<div class="paragraph">
<p>如果直接使用常量，优化器则可以选择最佳的执行计划，那么为什么还要使用绑定参数呢？
原因在于生成并评估所有执行计划变体是一项巨大的工作，如果最终结果相同，这种努力往往得不偿失。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
不使用绑定参数就像每次都重新编译程序一样。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>决定构建专用还是通用执行计划，对于数据库而言是一个两难的选择。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">专用执行计划 VS 通用执行计划 </dt>
<dd>
<p><strong>专用执行计划</strong>：为了确保每次查询都能获得最佳的执行计划，数据库可以在每次查询执行时花费额外的精力去评估所有可能的计划变体。这需要进行全面的优化，但可能会导致显著的性能开销 。
<strong>通用执行计划</strong>: 为避免频繁的优化开销，数据库可以使用缓存的执行计划，这些执行计划是根据之前的查询生成的。然而，着可能会导致使用次优的执行计划，因为执行计划没有根据新的参数或数据状态进行更新。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>数据库无法在不实际进行全面优化的情况下，判断完整优化周期是否会带来不同的执行计划。数据库供应商尝试通过启发式方法解决这一困境，但成效甚微。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
启发式的方法包括更具查询的复杂性、历史执行时间、统计数据等因素决定是否要进行完整优化。
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
除了那些必须影响执行计划的值之外，开发者应该始终使用绑定参数。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>分布不均的状态码是一个很好的例子，如“代办”和“已完成”。“已完成”的条目数量往往比“代办”记录多出一个数量级。这种情况下，使用索引仅在搜索“代办”条目时才有意义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>绑定参数无法改变SQL结构。
因此不能将绑定参数用于表名或列名。
如果需要在运行时更改SQL语句结构，可以使用动态SQL。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</article>  </div>
</main>
<div class="modal micromodal-slide" id="modal-versions" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true">
            <main class="modal__content" id="modal-versions-content">
              <button data-micromodal-close class="modal-versions-close">
                <svg width="28px" height="28px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><defs><style>.cls-1h{fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px;}</style></defs><title/><g id="cross"><line class="cls-1h" x1="7" x2="25" y1="7" y2="25"/><line class="cls-1h" x1="7" x2="25" y1="25" y2="7"/></g></svg>
              </button>
              <div class="colset">
                <div class="col-left">

                  <ul class="nav-versions">
                      <li class="component">
                        <div>
                          <a class="title" href="../index.html">vhxnif site</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../index.html">
      default
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                  </ul>
                </div>
              </div>
            </main>
        </div>
    </div>
</div>

</div>
<footer class="footer flex">
    <div id="note-links">
        <img id="springlogo" src="../../_/img/note-logo.svg" alt="Note">
        <p>Life, the Universe and Everything.</p>
    </div>
</footer>
<script src="../../_/js/vendor/import.js"></script>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/spring-tabs.js" data-sync-storage-key="docs:preferred-tab"></script>
  </body>
</html>
